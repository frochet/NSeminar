 \documentclass[10pt,article]{IEEEtran}
\usepackage{cite}
\usepackage[cmex10]{amsmath}
\usepackage{array}
\usepackage{url}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{verbatim}
\usepackage{lmodern}
\begin{document}
\title{Automated troubleshooting toolset for SDNs}

\author{\IEEEauthorblockN{Knop Thibaut, Rochet Florentin\\}
\IEEEauthorblockA{EPL,
UCL\\
Louvain-la-Neuve, Belgique\\
\{thibaut.knop,florentin.rochet\}@student.uclouvain.be}}


\maketitle
\begin{abstract}
TODO
\end{abstract}

\begin{IEEEkeywords}
TODO
\end{IEEEkeywords}

\section{Introduction}


For many years, the debugging have always been one of the major concerns in network maintenance. In order to localize problems into the network, operators usually use a narrow toolset, composed of traditional tools as \verb@ping@, \verb@traceroute@ and \verb@SNMP@ agents\cite{zeng2012automatic}.\\
Hopefully, this difficult and time-consuming\cite{zeng2012automatic} process could change, given the deployment of Software-Defined Networks. In a nutshell, SDNs are based on a separation between control- and data planes, which offer the opportunity of programmable networks\cite{mckeown2008openflow}. Those SDNs are composed of a network of switches managed by a logically-centralized controller, whose role is to (un-)install rules into the flow table of the switches, to read traffic statistics and respond to the network activity.\\
However, and because SDNs allows different operators and developers to dynamically program the same network, the complexity of software will increase\cite{Sherwood:2010:PNT:1924943.1924969} and potentially the numbers of bugs.
To minimise the trade-off between introducing new functionality and  increase the number of bugs in the network, there is a serious need for a complete and effective automated testing toolset, allowing the admins to focus on fixing the issues instead of localizing them. In traditional network architecture, it is almost impossible to create such an automated test suite, due to the complexity of \textit{knowing the operator's intent} and \textit{checking network behavior against intent}\cite{Heller:2013:LSL:2491185.2491197} (for more information about how traditional networks could be extended to support automated troubleshooting, please refer to \cite{Heller:2013:LSL:2491185.2491197}).\\
As we will explain (see Section~\ref{layering}), we use the different layers of the SDN stack to review the available tools for automated troubleshooting. Note that the methodology and the structure of this paper is influenced from the one used in\cite{Heller:2013:LSL:2491185.2491197}. It indeed seems the better way to articulate and present the different tools destined to localize the problems and their cause in an automated way.
The paper is structured as follow : first we recall the different layers of the SDN stack, and how it can be leveraged to provide automated troubleshooting for SDNs, then we present different existing tools by positioning them regarding the SDN layering, and we eventually conclude.

\section{SDN layering, the key used to a better troubleshooting}\label{layering}
 % Expliquer ici la stack SDN (decomposition en layer) et donner l'intuition concernant la plus grande facilité pour remonter à l'origine d'un probleme.
Finding and solving network bugs are not the aim of SDN, but we can use it to re-think the way we troubleshoot networks.\\ The SDN architecture is decomposed into  layers, those layers can be represented in a two dimensionnal array. As you can see on Figure \ref{layers}, we have the two main layers called \textit{State layers} and \textit{Code layers}. The state layers hold a representation of the network's configuration for each parts of the network architecture. The code layers implement logic to maintain the mapping between two state layers. Each states layers should verify the equivalence properties, which means that each of them should correctly mapping every other state layer. The idea is that, for each policy, if the state layers are correctly mapped among each other, then the policy is  set and acts like it should.\\
Thus, thanks to the SDN stack, we are able to first build a tool to check consistency between state layers in order to identify on which part of the network architecture a bug is happening. \\
When the layer is identified, an other tool take over to localize the issue inside the code layer. We will see in (TODO: indicates next section) which kind of tools could be used to handle that.
\begin{itemize}
\item explication graphique
\item plus en détail finding the code layer and finding within the code layer. (summary)
\end{itemize}
\begin{figure}
\includegraphics[scale=0.65]{layers.png}
\label{layers}
\caption{SDN architecture}
\end{figure}
\section{Network Troubleshooting - Tools}

\subsection{Network Debugger (NDB)}

\subsection{VeriFlow}
If the actual behavior of the network does not correspond to the policy, then the issue can potentially be found in the erroneous correspondance between the device state and the policy. There exist different tools to verify this hypothesis. The tools we discuss here have the advantage to verify some network invariants in real-time. Other tools as Anteater and Header Space Analysis (HSA) that are also used in the same purpose carry out the static analysis of snapshots of the network data-plane state\cite{Kazemian:2012:HSA:2228298.2228311}\cite{Mai:2011:DDP:2018436.2018470}. Since SDN controllers are capable of installing around 30.000 flows per second while maintaining less than 10 ms as delay for the installation, it is absolutely not enough to have tools that check for network invariant with a latency of the order of seconds \cite{Khurshid:2013:VVN:2482626.2482630}.\\
VeriFlow acts as a proxy in between the SDN controller and the switches that verifies some common network invariants at each forwarding rule installation at very high speed. In order to achieve a 7ms delay inflation with regards to traditional TCP connections, VeriFlow slices the network into equivalences classes, then builds a virtual forwarding graph for each ones using a trie structure, and finally checks invariants by traversing those graph with a depth-first search approach. Note that VeriFlow allows to spotting network issues before they reach the network, which is very valuable.

\subsection{SOFT - \textit{Systematic OpenFlow Testing}}

\subsection{NICE - \textit{No Bugs in Controller Execution}}

\subsection{FlowChecker}



\section{Conclusion}


\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,draft}

\end{document}
